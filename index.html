<!-- 11. 컴포넌트 성능 최적화 -->

<!-- 11.1 많은 데이터 렌더링하기 -->

<!-- 11.2 크롬 개발자 도구를 통한 성능 모니터링 -->

<!-- React DevTools를 사용하면 정확히 몇 초가 걸리는지 확인할 수 있다. 리액트 개발자 도구의 Profiler 탭을 열고, 녹화를
시작한 후 화면에 변화가 생기면 녹화를 끝낸다. Render duration이 리렌더링에 소요된 시간을 의미한다. Profiler 탭의
상단에 있는 랭크 차트 아이콘은 리렌더링된 컴포넌트를 오래 걸린 순으로 정렬하여 나열해준다. -->

<!-- 11.3 느려지는 원인 분석 -->

<!-- 컴포넌트는 다음과 같은 상황에서 리렌더링이 발생합니다.

- 자신이 전달받은 props가 변경될 때
- 자신의 state가 바뀔 때
- 부모 컴포넌트가 리렌더링될 때
- forceUpdate 함수가 실행될 때

현재 상황을 분석해 보면, '할 일 1' 항목을 체크할 경우 App 컴포넌트의 state가 변경되면서 App 컴포넌트가 리렌더링됩니다.
부모 컴포넌트가 리렌더링되었으니 TodoList 컴포넌트가 리렌더링되고 그 안의 무수한 컴포넌트들도 리렌더링됩니다.

'할 일 1' 항목은 리렌더링되어야 하는 것이 맞지만, '할 일 2'부터 '할 일 2500'까지는 리렌더링을 안 해도 되는 상황인데
모두 리렌더링되고 있으므로 이렇게 느린 것입니다. 컴포넌트의 개수가 많지 않다면 모든 컴포넌트를 리렌더링해도 느려지지
않는데, 지금처럼 약 2,000개가 넘어가면 성능이 저하됩니다.

이럴 때는 컴포넌트 리렌더링 성능을 최적화해 주는 작업을 해 주어야 합니다. 즉, 리렌더링이 불필요할 때는 리렌더링을
방지해 주어야 합니다. -->

<!-- 11.4 React.memo를 사용하여 컴포넌트 성능 최적화 -->

<!-- 컴포넌트의 리렌더링을 방지할 때는 shouldComponentUpdate라는 라이프사이클을 사용하면 됩니다. 그런데 함수 컴포넌트
에서는 라이프사이클 메소드를 사용할 수 없습니다. 그 대신 React.memo라는 함수를 사용합니다. 컴포넌트의 props가 바뀌지
않았다면, 리렌더링하지 않도록 설정하여 함수 컴포넌트의 리렌더링 성능을 최적화해 줄 수 있습니다. -->

<!-- 11.5 onToggle, onRemove 함수가 바뀌지 않게 하기 -->

<!-- React.memo를 사용하는 것만으로 컴포넌트 최적화가 끝나지는 않습니다. 현재 프로젝트에서는 todos 배열이 업데이트되면
onRemove와 onToggle 함수도 새롭게 바뀌기 때문입니다. onRemove와 onToggle 함수는 배열 상태를 업데이트하는 과정에서
최신 상태의 todos를 참조하기 때문에 todos 배열이 바뀔 때마다 함수가 새로 만들어집니다. 이렇게 함수가 계속 만들어지는
상황을 방지하는 방법은 두 가지입니다. 첫 번째 방법은 useState의 함수형 업데이트 기능을 사용하는 것이고, 두 번째 방법은
useReducer를 사용하는 것입니다. -->

<!-- 11.5.1 useState의 함수형 업데이트 -->

<!-- 기존에 setTodos 함수를 사용할 때는 새로운 상태를 파라미터로 넣어주었습니다. setTodos를 사용할 때 새로운 상태를
파라미터로 넣는 대신, 상태 업데이트를 어떻게 할지 정의해 주는 업데이트 함수를 넣을 수도 있습니다. 이를 함수형 업데이트
라고 부릅니다. -->

<!-- 11.5.2 useReducer 사용하기 -->

<!-- useReducer를 사용하는 방법은 기존 코드를 많이 고쳐야 한다는 단점이 있지만, 상태를 업데이트하는 로직을 모아서
컴포넌트 바깥에 둘 수 있다는 장점이 있습니다. -->

<!-- 11.6 불변성의 중요성 -->

<!-- 리액트 컴포넌트에서 상태를 업데이트할 때 불변성을 지키는 것은 매우 중요합니다. 기존 데이터를 수정할 때 직접 수정하지
않고, 새로운 배열을 만든 다음에 새로운 객체를 만들어서 필요한 부분을 교체해 주는 방식으로 구현했습니다. 업데이트가
필요한 곳에서는 아예 새로운 배열 혹은 새로운 객체를 만들기 때문에, React.memo를 사용했을 때 props가 바뀌었는지 혹은
바뀌지 않았는지를 알아내서 리렌더링 성능을 최적화해 줄 수 있습니다.

이렇게 기존의 값을 수정하지 않으면서 새로운 값을 만들어 내는 것을 '불변성을 지킨다'고 합니다. 불변성이 지켜지지 않으면
객체 내부의 값이 새로워져도 바뀐 것을 감지하지 못합니다. 그러면 React.memo에서 서로 비교하여 최적화하는 것이 불가능
합니다.

배열 혹은 객체의 구조가 정말 복잡해진다면 이렇게 불변성을 유지하면서 업데이트하는 것도 까다로워집니다. 이렇게 복잡한
상황일 경우 immer라는 라이브러리의 도움을 받으면 정말 편하게 작업할 수 있습니다. -->

<!-- 11.7 TodoList 컴포넌트 최적화하기 -->

<!-- 리스트에 관련된 컴포넌트를 최적화할 때는 리스트 내부에서 사용하는 컴포넌트도 최적화해야 하고, 리스트로 사용되는
컴포넌트 자체도 최적화해 주는 것이 좋습니다. -->